'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
        var n = {};
        if (e) {
            Object.keys(e).forEach(function (k) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            });
        }
        n['default'] = e;
        return n;
    }
}

const fetchache = require('fetchache');
const isUrl = _interopDefault(require('is-url'));
const jsYaml = require('js-yaml');
const path = require('path');
const stringInterpolation = require('@ardatan/string-interpolation');
const dateFns = require('date-fns');
const objectHash = _interopDefault(require('object-hash'));
const graphql = require('graphql');
const utils = require('@graphql-tools/utils');

async function readFileOrUrlWithCache(filePathOrUrl, cache, config) {
    if (isUrl(filePathOrUrl)) {
        return readUrlWithCache(filePathOrUrl, cache, config);
    }
    else {
        return readFileWithCache(filePathOrUrl, cache, config);
    }
}
async function readFileWithCache(filePath, cache, config) {
    const { readFile, stat } = await new Promise(function (resolve) { resolve(_interopNamespace(require('fs-extra'))); });
    const actualPath = path.isAbsolute ? filePath : path.resolve(process.cwd(), filePath);
    const cachedObjStr = await cache.get(actualPath);
    const stats = await stat(actualPath);
    if (cachedObjStr) {
        const cachedObj = JSON.parse(cachedObjStr);
        if (stats.mtimeMs <= cachedObj.mtimeMs) {
            return cachedObj.result;
        }
    }
    let result = await readFile(actualPath, 'utf-8');
    if (/json$/.test(filePath)) {
        result = JSON.parse(result);
    }
    else if (/yaml$/.test(filePath) || /yml$/.test(filePath)) {
        result = jsYaml.safeLoad(result);
    }
    else if (config === null || config === void 0 ? void 0 : config.fallbackFormat) {
        switch (config.fallbackFormat) {
            case 'json':
                result = JSON.parse(result);
                break;
            case 'yaml':
                result = jsYaml.safeLoad(result);
                break;
        }
    }
    else if (!(config === null || config === void 0 ? void 0 : config.allowUnknownExtensions)) {
        throw new Error(`Failed to parse JSON/YAML. Ensure file '${filePath}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml).`);
    }
    cache.set(filePath, JSON.stringify({ result, mtimeMs: stats.mtimeMs }));
    return result;
}
async function readUrlWithCache(path, cache, config) {
    var _a;
    const response = await fetchache.fetchache(new fetchache.Request(path, config), cache);
    const contentType = ((_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type')) || '';
    const responseText = await response.text();
    if (/json$/.test(path) || contentType.startsWith('application/json')) {
        return JSON.parse(responseText);
    }
    else if (/yaml$/.test(path) || /yml$/.test(path) || contentType.includes('yaml') || contentType.includes('yml')) {
        return jsYaml.safeLoad(responseText);
    }
    else if (!(config === null || config === void 0 ? void 0 : config.allowUnknownExtensions)) {
        throw new Error(`Failed to parse JSON/YAML. Ensure URL '${path}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml) or mime type in the response headers.`);
    }
    return responseText;
}

const stringInterpolator = new stringInterpolation.Interpolator({
    delimiter: ['{', '}'],
});
stringInterpolator.addAlias('typeName', 'info.parentType.name');
stringInterpolator.addAlias('type', 'info.parentType.name');
stringInterpolator.addAlias('parentType', 'info.parentType.name');
stringInterpolator.addAlias('fieldName', 'info.fieldName');
stringInterpolator.registerModifier('date', (formatStr) => dateFns.format(new Date(), formatStr));
stringInterpolator.registerModifier('hash', (value) => objectHash(value, { ignoreUnknown: true }));

async function loadFromModuleExportExpression(expression, defaultExportName) {
    if (typeof expression !== 'string') {
        return expression;
    }
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    const mod = await tryImport(modulePath);
    if (exportName === 'default' || !exportName) {
        return mod.default || mod;
    }
    else {
        return mod[exportName] || (mod.default && mod.default[exportName]);
    }
}
async function tryImport(modulePath) {
    try {
        return await new Promise(function (resolve) { resolve(_interopNamespace(require(modulePath))); });
    }
    catch (e1) {
        if (!path.isAbsolute(modulePath)) {
            try {
                const absoluteModulePath = path.isAbsolute(modulePath) ? modulePath : path.join(process.cwd(), modulePath);
                return await new Promise(function (resolve) { resolve(_interopNamespace(require(absoluteModulePath))); });
            }
            catch (e2) {
                if (e2.message.includes('Cannot find module')) {
                    throw e1;
                }
                else {
                    throw e2;
                }
            }
        }
        throw e1;
    }
}
function loadFromModuleExportExpressionSync(expression, defaultExportName) {
    if (typeof expression !== 'string') {
        return expression;
    }
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    const mod = tryImportSync(modulePath);
    if (exportName === 'default' || !exportName) {
        return mod.default || mod;
    }
    else {
        return mod[exportName] || (mod.default && mod.default[exportName]);
    }
}
function tryImportSync(modulePath) {
    try {
        return require(modulePath);
    }
    catch (e1) {
        if (!path.isAbsolute(modulePath)) {
            try {
                const absoluteModulePath = path.isAbsolute(modulePath) ? modulePath : path.join(process.cwd(), modulePath);
                return require(absoluteModulePath);
            }
            catch (e2) {
                if (e2.message.includes('Cannot find module')) {
                    throw e1;
                }
                else {
                    throw e2;
                }
            }
        }
        throw e1;
    }
}

(function (ArgType) {
    ArgType["ID"] = "ID";
    ArgType["String"] = "String";
    ArgType["Boolean"] = "Boolean";
    ArgType["Float"] = "Float";
    ArgType["Int"] = "Int";
})(exports.ArgType || (exports.ArgType = {}));
function getInputTypeFromTypeName(typeName) {
    if (graphql.isInputType(typeName)) {
        return typeName;
    }
    else {
        switch (typeName) {
            case exports.ArgType.ID:
                return graphql.GraphQLID;
            case exports.ArgType.String:
                return graphql.GraphQLString;
            case exports.ArgType.Boolean:
                return graphql.GraphQLBoolean;
            case exports.ArgType.Float:
                return graphql.GraphQLFloat;
            case exports.ArgType.Int:
                return graphql.GraphQLInt;
        }
    }
}
function parseInterpolationStrings(interpolationStrings, argTypeMap) {
    const interpolationKeys = interpolationStrings.reduce((keys, str) => [...keys, ...(str ? stringInterpolator.parseRules(str).map((match) => match.key) : [])], []);
    const args = {};
    const contextVariables = [];
    for (const interpolationKey of interpolationKeys) {
        const interpolationKeyParts = interpolationKey.split('.');
        const varName = interpolationKeyParts[interpolationKeyParts.length - 1];
        if (interpolationKeyParts[0] === 'args') {
            const argType = argTypeMap && varName in argTypeMap ? getInputTypeFromTypeName(argTypeMap[varName]) : graphql.GraphQLID;
            args[varName] = {
                type: argType,
            };
        }
        else if (interpolationKeyParts[0] === 'context') {
            contextVariables.push(varName);
        }
    }
    return {
        args,
        contextVariables,
    };
}
function getInterpolatedStringFactory(nonInterpolatedString) {
    return resolverData => stringInterpolator.parse(nonInterpolatedString, resolverData);
}
function getInterpolatedHeadersFactory(nonInterpolatedHeaders = {}) {
    return resolverData => {
        const headers = new fetchache.Headers();
        for (const headerName in nonInterpolatedHeaders) {
            const headerValue = nonInterpolatedHeaders[headerName];
            if (headerValue) {
                headers.set(headerName, stringInterpolator.parse(headerValue, resolverData));
            }
        }
        return headers;
    };
}
function getHeadersObject(headers) {
    const headersObj = {};
    headers.forEach((value, key) => {
        headersObj[key] = value;
    });
    return headersObj;
}

function withCancel(asyncIteratorLike, onCancel) {
    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();
    if (!asyncIterator.return) {
        asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });
    }
    const savedReturn = asyncIterator.return.bind(asyncIterator);
    asyncIterator.return = () => {
        onCancel();
        return savedReturn();
    };
    return asyncIterator;
}

function extractResolvers(schema) {
    const allResolvers = utils.getResolversFromSchema(schema);
    const filteredResolvers = {};
    for (const prop in allResolvers) {
        if (!prop.startsWith('_')) {
            filteredResolvers[prop] = allResolvers[prop];
        }
    }
    return filteredResolvers;
}

function ensureDocumentNode(document) {
    return typeof document === 'string' ? graphql.parse(document) : document;
}

function groupTransforms(transforms) {
    const wrapTransforms = [];
    const noWrapTransforms = [];
    transforms === null || transforms === void 0 ? void 0 : transforms.forEach(transform => {
        if (transform.noWrap) {
            noWrapTransforms.push(transform);
        }
        else {
            wrapTransforms.push(transform);
        }
    });
    return { wrapTransforms, noWrapTransforms };
}

exports.isUrl = isUrl;
exports.ensureDocumentNode = ensureDocumentNode;
exports.extractResolvers = extractResolvers;
exports.getHeadersObject = getHeadersObject;
exports.getInputTypeFromTypeName = getInputTypeFromTypeName;
exports.getInterpolatedHeadersFactory = getInterpolatedHeadersFactory;
exports.getInterpolatedStringFactory = getInterpolatedStringFactory;
exports.groupTransforms = groupTransforms;
exports.loadFromModuleExportExpression = loadFromModuleExportExpression;
exports.loadFromModuleExportExpressionSync = loadFromModuleExportExpressionSync;
exports.parseInterpolationStrings = parseInterpolationStrings;
exports.readFileOrUrlWithCache = readFileOrUrlWithCache;
exports.readFileWithCache = readFileWithCache;
exports.readUrlWithCache = readUrlWithCache;
exports.stringInterpolator = stringInterpolator;
exports.withCancel = withCancel;
//# sourceMappingURL=index.cjs.js.map
