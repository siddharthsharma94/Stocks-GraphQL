import { fetchache, Request, Headers } from 'fetchache';
import isUrl from 'is-url';
export { default as isUrl } from 'is-url';
import { safeLoad } from 'js-yaml';
import { isAbsolute, resolve, join } from 'path';
import { Interpolator } from '@ardatan/string-interpolation';
import { format } from 'date-fns';
import objectHash from 'object-hash';
import { isInputType, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLString, GraphQLID, parse } from 'graphql';
import { getResolversFromSchema } from '@graphql-tools/utils';

async function readFileOrUrlWithCache(filePathOrUrl, cache, config) {
    if (isUrl(filePathOrUrl)) {
        return readUrlWithCache(filePathOrUrl, cache, config);
    }
    else {
        return readFileWithCache(filePathOrUrl, cache, config);
    }
}
async function readFileWithCache(filePath, cache, config) {
    const { readFile, stat } = await import('fs-extra');
    const actualPath = isAbsolute ? filePath : resolve(process.cwd(), filePath);
    const cachedObjStr = await cache.get(actualPath);
    const stats = await stat(actualPath);
    if (cachedObjStr) {
        const cachedObj = JSON.parse(cachedObjStr);
        if (stats.mtimeMs <= cachedObj.mtimeMs) {
            return cachedObj.result;
        }
    }
    let result = await readFile(actualPath, 'utf-8');
    if (/json$/.test(filePath)) {
        result = JSON.parse(result);
    }
    else if (/yaml$/.test(filePath) || /yml$/.test(filePath)) {
        result = safeLoad(result);
    }
    else if (config === null || config === void 0 ? void 0 : config.fallbackFormat) {
        switch (config.fallbackFormat) {
            case 'json':
                result = JSON.parse(result);
                break;
            case 'yaml':
                result = safeLoad(result);
                break;
        }
    }
    else if (!(config === null || config === void 0 ? void 0 : config.allowUnknownExtensions)) {
        throw new Error(`Failed to parse JSON/YAML. Ensure file '${filePath}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml).`);
    }
    cache.set(filePath, JSON.stringify({ result, mtimeMs: stats.mtimeMs }));
    return result;
}
async function readUrlWithCache(path, cache, config) {
    var _a;
    const response = await fetchache(new Request(path, config), cache);
    const contentType = ((_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type')) || '';
    const responseText = await response.text();
    if (/json$/.test(path) || contentType.startsWith('application/json')) {
        return JSON.parse(responseText);
    }
    else if (/yaml$/.test(path) || /yml$/.test(path) || contentType.includes('yaml') || contentType.includes('yml')) {
        return safeLoad(responseText);
    }
    else if (!(config === null || config === void 0 ? void 0 : config.allowUnknownExtensions)) {
        throw new Error(`Failed to parse JSON/YAML. Ensure URL '${path}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml) or mime type in the response headers.`);
    }
    return responseText;
}

const stringInterpolator = new Interpolator({
    delimiter: ['{', '}'],
});
stringInterpolator.addAlias('typeName', 'info.parentType.name');
stringInterpolator.addAlias('type', 'info.parentType.name');
stringInterpolator.addAlias('parentType', 'info.parentType.name');
stringInterpolator.addAlias('fieldName', 'info.fieldName');
stringInterpolator.registerModifier('date', (formatStr) => format(new Date(), formatStr));
stringInterpolator.registerModifier('hash', (value) => objectHash(value, { ignoreUnknown: true }));

async function loadFromModuleExportExpression(expression, defaultExportName) {
    if (typeof expression !== 'string') {
        return expression;
    }
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    const mod = await tryImport(modulePath);
    if (exportName === 'default' || !exportName) {
        return mod.default || mod;
    }
    else {
        return mod[exportName] || (mod.default && mod.default[exportName]);
    }
}
async function tryImport(modulePath) {
    try {
        return await import(modulePath);
    }
    catch (e1) {
        if (!isAbsolute(modulePath)) {
            try {
                const absoluteModulePath = isAbsolute(modulePath) ? modulePath : join(process.cwd(), modulePath);
                return await import(absoluteModulePath);
            }
            catch (e2) {
                if (e2.message.includes('Cannot find module')) {
                    throw e1;
                }
                else {
                    throw e2;
                }
            }
        }
        throw e1;
    }
}
function loadFromModuleExportExpressionSync(expression, defaultExportName) {
    if (typeof expression !== 'string') {
        return expression;
    }
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    const mod = tryImportSync(modulePath);
    if (exportName === 'default' || !exportName) {
        return mod.default || mod;
    }
    else {
        return mod[exportName] || (mod.default && mod.default[exportName]);
    }
}
function tryImportSync(modulePath) {
    try {
        return require(modulePath);
    }
    catch (e1) {
        if (!isAbsolute(modulePath)) {
            try {
                const absoluteModulePath = isAbsolute(modulePath) ? modulePath : join(process.cwd(), modulePath);
                return require(absoluteModulePath);
            }
            catch (e2) {
                if (e2.message.includes('Cannot find module')) {
                    throw e1;
                }
                else {
                    throw e2;
                }
            }
        }
        throw e1;
    }
}

var ArgType;
(function (ArgType) {
    ArgType["ID"] = "ID";
    ArgType["String"] = "String";
    ArgType["Boolean"] = "Boolean";
    ArgType["Float"] = "Float";
    ArgType["Int"] = "Int";
})(ArgType || (ArgType = {}));
function getInputTypeFromTypeName(typeName) {
    if (isInputType(typeName)) {
        return typeName;
    }
    else {
        switch (typeName) {
            case ArgType.ID:
                return GraphQLID;
            case ArgType.String:
                return GraphQLString;
            case ArgType.Boolean:
                return GraphQLBoolean;
            case ArgType.Float:
                return GraphQLFloat;
            case ArgType.Int:
                return GraphQLInt;
        }
    }
}
function parseInterpolationStrings(interpolationStrings, argTypeMap) {
    const interpolationKeys = interpolationStrings.reduce((keys, str) => [...keys, ...(str ? stringInterpolator.parseRules(str).map((match) => match.key) : [])], []);
    const args = {};
    const contextVariables = [];
    for (const interpolationKey of interpolationKeys) {
        const interpolationKeyParts = interpolationKey.split('.');
        const varName = interpolationKeyParts[interpolationKeyParts.length - 1];
        if (interpolationKeyParts[0] === 'args') {
            const argType = argTypeMap && varName in argTypeMap ? getInputTypeFromTypeName(argTypeMap[varName]) : GraphQLID;
            args[varName] = {
                type: argType,
            };
        }
        else if (interpolationKeyParts[0] === 'context') {
            contextVariables.push(varName);
        }
    }
    return {
        args,
        contextVariables,
    };
}
function getInterpolatedStringFactory(nonInterpolatedString) {
    return resolverData => stringInterpolator.parse(nonInterpolatedString, resolverData);
}
function getInterpolatedHeadersFactory(nonInterpolatedHeaders = {}) {
    return resolverData => {
        const headers = new Headers();
        for (const headerName in nonInterpolatedHeaders) {
            const headerValue = nonInterpolatedHeaders[headerName];
            if (headerValue) {
                headers.set(headerName, stringInterpolator.parse(headerValue, resolverData));
            }
        }
        return headers;
    };
}
function getHeadersObject(headers) {
    const headersObj = {};
    headers.forEach((value, key) => {
        headersObj[key] = value;
    });
    return headersObj;
}

function withCancel(asyncIteratorLike, onCancel) {
    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();
    if (!asyncIterator.return) {
        asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });
    }
    const savedReturn = asyncIterator.return.bind(asyncIterator);
    asyncIterator.return = () => {
        onCancel();
        return savedReturn();
    };
    return asyncIterator;
}

function extractResolvers(schema) {
    const allResolvers = getResolversFromSchema(schema);
    const filteredResolvers = {};
    for (const prop in allResolvers) {
        if (!prop.startsWith('_')) {
            filteredResolvers[prop] = allResolvers[prop];
        }
    }
    return filteredResolvers;
}

function ensureDocumentNode(document) {
    return typeof document === 'string' ? parse(document) : document;
}

function groupTransforms(transforms) {
    const wrapTransforms = [];
    const noWrapTransforms = [];
    transforms === null || transforms === void 0 ? void 0 : transforms.forEach(transform => {
        if (transform.noWrap) {
            noWrapTransforms.push(transform);
        }
        else {
            wrapTransforms.push(transform);
        }
    });
    return { wrapTransforms, noWrapTransforms };
}

export { ArgType, ensureDocumentNode, extractResolvers, getHeadersObject, getInputTypeFromTypeName, getInterpolatedHeadersFactory, getInterpolatedStringFactory, groupTransforms, loadFromModuleExportExpression, loadFromModuleExportExpressionSync, parseInterpolationStrings, readFileOrUrlWithCache, readFileWithCache, readUrlWithCache, stringInterpolator, withCancel };
//# sourceMappingURL=index.esm.js.map
