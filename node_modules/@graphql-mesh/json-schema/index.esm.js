import { pascalCase } from 'pascal-case';
import { dirname, isAbsolute, join } from 'path';
import { readJSONSync, pathExists, stat, writeJSON } from 'fs-extra';
import { flatten, get, camelCase } from 'lodash';
import { RegularExpression, GraphQLJSON, GraphQLVoid, GraphQLDateTime, GraphQLDate, GraphQLTime, GraphQLTimestamp, GraphQLPhoneNumber, GraphQLURL, GraphQLEmailAddress, GraphQLIPv4, GraphQLIPv6 } from 'graphql-scalars';
import Ajv from 'ajv';
import urlJoin from 'url-join';
import { readFileOrUrlWithCache, isUrl, parseInterpolationStrings, stringInterpolator } from '@graphql-mesh/utils';
import AggregateError from 'aggregate-error';
import { Request, fetchache } from 'fetchache';
import { SchemaComposer } from 'graphql-compose';
import toJsonSchema from 'to-json-schema';

const asArray = (maybeArray) => {
    if (Array.isArray(maybeArray)) {
        return maybeArray;
    }
    else if (maybeArray) {
        return [maybeArray];
    }
    else {
        return [];
    }
};
const invalidSeperators = [':', '>', '<', '.'];
const VALID_FIELD_NAME = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
const getFileName = (filePath) => {
    const arr = filePath.split('/').map(part => part.split('\\'));
    return flatten(arr).pop().split('.').join('_');
};
class JSONSchemaVisitor {
    constructor(schemaComposer, isInput, externalFileCache = new Map(), disableTimestamp = false) {
        this.schemaComposer = schemaComposer;
        this.isInput = isInput;
        this.externalFileCache = externalFileCache;
        this.disableTimestamp = disableTimestamp;
        // TODO: Should be improved!
        this.visitedRefNameMap = new Map();
        this.namedVisitedDefs = new Set();
        this.ajv = new Ajv({
            schemaId: 'auto',
            missingRefs: 'ignore',
            logger: false,
        });
        // Settings for draft-04
        const metaSchema = require('ajv/lib/refs/json-schema-draft-04.json');
        this.ajv.addMetaSchema(metaSchema);
        this.cache = new Map();
    }
    createName({ ref, cwd }) {
        if (this.visitedRefNameMap.has(ref)) {
            return this.visitedRefNameMap.get(ref);
        }
        let [externalPath, internalRef] = ref.split('#');
        // If a reference
        if (internalRef) {
            const cwdDir = dirname(cwd);
            const absolutePath = externalPath ? (isAbsolute(externalPath) ? externalPath : join(cwdDir, externalPath)) : cwd;
            const fileName = getFileName(absolutePath);
            if (!this.externalFileCache.has(absolutePath)) {
                const externalSchema = readJSONSync(absolutePath);
                this.externalFileCache.set(absolutePath, externalSchema);
                this.visit({
                    def: externalSchema,
                    propertyName: this.isInput ? 'Request' : 'Response',
                    prefix: fileName,
                    cwd: absolutePath,
                    ignoreResult: true,
                });
            }
            const internalRefArr = internalRef.split('/').filter(Boolean);
            const internalPath = internalRefArr.join('.');
            const internalPropertyName = internalRefArr[internalRefArr.length - 1];
            const internalDef = get(this.externalFileCache.get(absolutePath), internalPath);
            const result = this.visit({
                def: internalDef,
                propertyName: internalPropertyName,
                prefix: fileName,
                cwd: absolutePath,
                typeName: internalRef.includes('definitions/') && internalPropertyName,
            });
            this.visitedRefNameMap.set(ref, result);
            return result;
        }
        else {
            internalRef = ref;
        }
        internalRef = internalRef.split('/').pop();
        for (const sep of invalidSeperators) {
            internalRef = internalRef.split(sep).join('_');
        }
        let name = pascalCase(internalRef);
        if (this.schemaComposer.has(name)) {
            const fileNamePrefix = getFileName(cwd).split('.').join('_');
            return pascalCase(fileNamePrefix + '_' + name);
        }
        if (/^[0-9]/.test(name) || name === '') {
            name = '_' + name;
        }
        this.visitedRefNameMap.set(ref, name);
        return name;
    }
    visit({ def, propertyName, prefix, cwd, ignoreResult, typeName, }) {
        if (typeName) {
            if (typeName === 'Subscription') {
                typeName = prefix + 'Subscription';
            }
            if (this.namedVisitedDefs.has(typeName)) {
                return typeName;
            }
            this.namedVisitedDefs.add(typeName);
        }
        def.type = Array.isArray(def.type) ? def.type[0] : def.type;
        const summary = JSON.stringify(def);
        if (this.cache.has(summary)) {
            return this.cache.get(summary);
        }
        if ('definitions' in def) {
            for (const propertyName in def.definitions) {
                const definition = def.definitions[propertyName];
                this.visit({ def: definition, propertyName, prefix, cwd, typeName: propertyName });
            }
        }
        if ('$defs' in def) {
            for (const propertyName in def.$defs) {
                const definition = def.$defs[propertyName];
                this.visit({ def: definition, propertyName, prefix, cwd });
            }
        }
        let result;
        switch (def.type) {
            case 'array':
                result = this.visitArray({ arrayDef: def, propertyName, prefix, cwd, typeName });
                break;
            case 'boolean':
                result = this.visitBoolean();
                break;
            case 'integer':
                result = this.visitInteger();
                break;
            case 'number':
                result = this.visitNumber();
                break;
            case 'string':
                if ('enum' in def) {
                    result = this.visitEnum({ enumDef: def, propertyName, prefix, cwd, typeName });
                }
                else {
                    result = this.visitString({ stringDef: def, propertyName, prefix, cwd, typeName });
                }
                break;
            case 'null':
                result = this.visitNull();
                break;
            case 'any':
                result = this.visitAny();
                break;
            default:
                if ('name' in def || 'title' in def) {
                    result = this.visitTypedNamedObjectDefinition({ typedNamedObjectDef: def, cwd, typeName });
                }
                else if ('properties' in def) {
                    result = this.visitTypedUnnamedObjectDefinition({
                        typedUnnamedObjectDef: def,
                        propertyName,
                        prefix,
                        cwd,
                        typeName,
                    });
                }
                else if (('additionalProperties' in def && def.additionalProperties) || Object.keys(def).length === 1) {
                    result = this.visitAny();
                }
                else if ('$ref' in def) {
                    result = this.visitObjectReference({ objectRef: def, cwd, typeName });
                }
                else if ('enum' in def) {
                    result = this.visitEnum({ enumDef: def, propertyName, prefix, cwd, typeName });
                }
        }
        if ('oneOf' in def) {
            result = this.visitOneOfReference({ oneOfReference: def, propertyName, prefix, cwd, typeName });
        }
        if (!result && !ignoreResult) {
            console.warn(`Unknown JSON Schema definition for (${typeName || prefix}, ${propertyName})`);
            result = this.visitAny();
        }
        this.cache.set(summary, result);
        this.namedVisitedDefs.add(result);
        return result;
    }
    visitArray({ arrayDef, propertyName, prefix, cwd, typeName, }) {
        const [itemsDef] = asArray(arrayDef.items);
        let itemTypeName = 'JSON';
        if (itemsDef) {
            itemTypeName = this.visit({ def: itemsDef, propertyName, prefix, cwd, typeName });
        }
        return `[${itemTypeName}]`;
    }
    visitBoolean() {
        return 'Boolean';
    }
    visitInteger() {
        return 'Int';
    }
    visitNumber() {
        return 'Float';
    }
    visitString({ stringDef, propertyName, prefix, cwd, typeName, }) {
        if (stringDef.pattern) {
            let refName = `${prefix}_${propertyName}`;
            if ('format' in stringDef) {
                refName = stringDef.format;
            }
            const scalarName = typeName || this.createName({ ref: refName, cwd });
            this.schemaComposer.add(new RegularExpression(scalarName, new RegExp(stringDef.pattern)));
            return scalarName;
        }
        if (stringDef.format) {
            switch (stringDef.format) {
                case 'date-time':
                    return 'DateTime';
                case 'date':
                    return 'Date';
                case 'time':
                    return 'Time';
                case 'utc-millisec':
                    return this.disableTimestamp ? 'String' : 'Timestamp';
                case 'color':
                    return 'String'; // TODO
                case 'phone':
                    return 'PhoneNumber';
                case 'uri':
                    return 'URL';
                case 'email':
                    return 'EmailAddress';
                case 'ip-address':
                    return 'IPv4';
                case 'ipv6':
                    return 'IPv6';
                case 'style':
                    return 'String'; // TODO
            }
        }
        return 'String';
    }
    visitEnum({ enumDef, propertyName, prefix, cwd, typeName, }) {
        let refName = `${prefix}_${propertyName}`;
        if ('title' in enumDef) {
            refName = enumDef.title;
        }
        else if ('name' in enumDef) {
            refName = enumDef.name;
        }
        const name = typeName || this.createName({ ref: refName, cwd });
        this.schemaComposer.createEnumTC({
            name,
            values: enumDef.enum.reduce((values, enumValue) => ({
                ...values,
                [this.createName({ ref: enumValue, cwd })]: {
                    value: enumValue,
                },
            }), {}),
        });
        return name;
    }
    createFieldsMapFromProperties(objectDef, prefix, cwd) {
        var _a;
        const fieldMap = {};
        for (const propertyName in objectDef.properties) {
            let fieldName = propertyName;
            if (!VALID_FIELD_NAME.test(fieldName)) {
                fieldName = camelCase(propertyName);
            }
            if (/^[0-9]/.test(fieldName) || fieldName === '') {
                fieldName = `_${fieldName}`;
            }
            const property = objectDef.properties[propertyName];
            let type = this.visit({ def: property, propertyName, prefix, cwd });
            const isRequired = 'required' in objectDef && ((_a = objectDef.required) === null || _a === void 0 ? void 0 : _a.includes(propertyName));
            if (isRequired) {
                type += '!';
            }
            fieldMap[fieldName] = {
                type,
                description: property.description,
            };
            if (!this.isInput && fieldName !== propertyName) {
                fieldMap[fieldName].resolve = (root) => root[propertyName];
            }
        }
        return fieldMap;
    }
    getGraphQLObjectTypeWithTypedObjectDef({ objectDef, objectIdentifier, cwd, typeName, }) {
        const name = typeName || this.createName({ ref: objectIdentifier, cwd });
        const fields = this.createFieldsMapFromProperties(objectDef, name, cwd);
        if (this.isInput) {
            this.schemaComposer.createInputTC({
                name,
                fields,
                extensions: {
                    objectDef,
                },
            });
        }
        else {
            this.schemaComposer.createObjectTC({
                name,
                fields,
                extensions: {
                    objectDef,
                },
            });
        }
        return name;
    }
    visitTypedUnnamedObjectDefinition({ typedUnnamedObjectDef, propertyName, prefix, cwd, typeName, }) {
        return this.getGraphQLObjectTypeWithTypedObjectDef({
            objectDef: typedUnnamedObjectDef,
            objectIdentifier: prefix + '_' + propertyName,
            cwd,
            typeName,
        });
    }
    visitTypedNamedObjectDefinition({ typedNamedObjectDef, cwd, typeName, }) {
        const objectIdentifier = 'name' in typedNamedObjectDef ? typedNamedObjectDef.name : typedNamedObjectDef.title;
        return this.getGraphQLObjectTypeWithTypedObjectDef({
            objectDef: typedNamedObjectDef,
            objectIdentifier,
            cwd,
            typeName,
        });
    }
    visitObjectReference({ objectRef, cwd, typeName, }) {
        return typeName || this.createName({ ref: objectRef.$ref, cwd });
    }
    visitAny() {
        return 'JSON';
    }
    visitNull() {
        return 'Void';
    }
    visitOneOfReference({ oneOfReference, propertyName, prefix, cwd, typeName, }) {
        let unionIdentifier = oneOfReference.title;
        if (!unionIdentifier) {
            unionIdentifier = prefix + '_' + propertyName;
        }
        const unionName = typeName || this.createName({ ref: unionIdentifier, cwd });
        const types = oneOfReference.oneOf.map(def => this.visit({ def, propertyName, prefix, cwd }));
        this.schemaComposer.createUnionTC({
            name: unionName,
            types,
            resolveType: (root) => {
                if (root.__typename) {
                    return root.__typename;
                }
                for (const typeName of types) {
                    const typeDef = this.schemaComposer.getAnyTC(typeName);
                    const isValid = this.ajv.validate(typeDef.getExtension('objectDef'), root);
                    if (isValid) {
                        return typeName;
                    }
                }
                return null;
            },
        });
        return unionName;
    }
}

class JsonSchemaHandler {
    constructor({ config, cache, pubsub }) {
        this.schemaComposer = new SchemaComposer();
        this.config = config;
        this.cache = cache;
        this.pubsub = pubsub;
    }
    async getMeshSource() {
        var _a, _b;
        const schemaComposer = this.schemaComposer;
        schemaComposer.add(GraphQLJSON);
        schemaComposer.add(GraphQLVoid);
        schemaComposer.add(GraphQLDateTime);
        schemaComposer.add(GraphQLDate);
        schemaComposer.add(GraphQLTime);
        if (!this.config.disableTimestampScalar) {
            schemaComposer.add(GraphQLTimestamp);
        }
        schemaComposer.add(GraphQLPhoneNumber);
        schemaComposer.add(GraphQLURL);
        schemaComposer.add(GraphQLEmailAddress);
        schemaComposer.add(GraphQLIPv4);
        schemaComposer.add(GraphQLIPv6);
        const externalFileCache = new Map();
        const inputSchemaVisitor = new JSONSchemaVisitor(schemaComposer, true, externalFileCache, this.config.disableTimestampScalar);
        const outputSchemaVisitor = new JSONSchemaVisitor(schemaComposer, false, externalFileCache, this.config.disableTimestampScalar);
        const contextVariables = [];
        const typeNamedOperations = [];
        const unnamedOperations = [];
        if (this.config.baseSchema) {
            const basedFilePath = this.config.baseSchema;
            const baseSchema = await readFileOrUrlWithCache(basedFilePath, this.cache, {
                headers: this.config.schemaHeaders,
            });
            externalFileCache.set(basedFilePath, baseSchema);
            const baseFileName = getFileName(basedFilePath);
            outputSchemaVisitor.visit({
                def: baseSchema,
                propertyName: 'Base',
                prefix: baseFileName,
                cwd: basedFilePath,
            });
        }
        (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.operations) === null || _b === void 0 ? void 0 : _b.forEach(async (operationConfig) => {
            if (operationConfig.responseTypeName) {
                typeNamedOperations.push(operationConfig);
            }
            else {
                unnamedOperations.push(operationConfig);
            }
        });
        const handleOperations = async (operationConfig) => {
            let responseTypeName = operationConfig.responseTypeName;
            let [requestSchema, responseSchema] = await Promise.all([
                operationConfig.requestSample &&
                    this.generateJsonSchemaFromSample({
                        samplePath: operationConfig.requestSample,
                        schemaPath: operationConfig.requestSchema,
                    }),
                operationConfig.responseSample &&
                    this.generateJsonSchemaFromSample({
                        samplePath: operationConfig.responseSample,
                        schemaPath: operationConfig.responseSchema,
                    }),
            ]);
            [requestSchema, responseSchema] = await Promise.all([
                requestSchema ||
                    (operationConfig.requestSchema &&
                        readFileOrUrlWithCache(operationConfig.requestSchema, this.cache, {
                            headers: this.config.schemaHeaders,
                        })),
                responseSchema ||
                    (operationConfig.responseSchema &&
                        readFileOrUrlWithCache(operationConfig.responseSchema, this.cache, {
                            headers: this.config.schemaHeaders,
                        })),
            ]);
            operationConfig.method = operationConfig.method || (operationConfig.type === 'Mutation' ? 'POST' : 'GET');
            operationConfig.type = operationConfig.type || (operationConfig.method === 'GET' ? 'Query' : 'Mutation');
            const basedFilePath = operationConfig.responseSchema || operationConfig.responseSample;
            if (basedFilePath) {
                externalFileCache.set(basedFilePath, responseSchema);
                const responseFileName = getFileName(basedFilePath);
                responseTypeName = outputSchemaVisitor.visit({
                    def: responseSchema,
                    propertyName: 'Response',
                    prefix: responseFileName,
                    cwd: basedFilePath,
                    typeName: operationConfig.responseTypeName,
                });
            }
            const { args, contextVariables: specificContextVariables } = parseInterpolationStrings([
                ...Object.values(this.config.operationHeaders || {}),
                ...Object.values(operationConfig.headers || {}),
                operationConfig.path,
            ], operationConfig.argTypeMap);
            contextVariables.push(...specificContextVariables);
            let requestTypeName = operationConfig.requestTypeName;
            if (requestSchema) {
                const basedFilePath = operationConfig.requestSchema || operationConfig.requestSample;
                externalFileCache.set(basedFilePath, requestSchema);
                const requestFileName = getFileName(basedFilePath);
                requestTypeName = inputSchemaVisitor.visit({
                    def: requestSchema,
                    propertyName: 'Request',
                    prefix: requestFileName,
                    cwd: basedFilePath,
                    typeName: operationConfig.requestTypeName,
                });
            }
            if (requestTypeName) {
                args.input = {
                    type: requestTypeName,
                    description: requestSchema === null || requestSchema === void 0 ? void 0 : requestSchema.description,
                };
            }
            const destination = operationConfig.type;
            schemaComposer[destination].addFields({
                [operationConfig.field]: {
                    description: operationConfig.description || (responseSchema === null || responseSchema === void 0 ? void 0 : responseSchema.description) ||
                        `${operationConfig.method} ${operationConfig.path}`,
                    type: responseTypeName,
                    args,
                    resolve: async (root, args, context, info) => {
                        const interpolationData = { root, args, context, info };
                        if (operationConfig.pubsubTopic) {
                            const pubsubTopic = stringInterpolator.parse(operationConfig.pubsubTopic, interpolationData);
                            return this.pubsub.asyncIterator(pubsubTopic);
                        }
                        else if (operationConfig.path) {
                            const interpolatedPath = stringInterpolator.parse(operationConfig.path, interpolationData);
                            const fullPath = urlJoin(this.config.baseUrl, interpolatedPath);
                            const method = operationConfig.method;
                            const headers = {
                                ...this.config.operationHeaders,
                                ...operationConfig === null || operationConfig === void 0 ? void 0 : operationConfig.headers,
                            };
                            for (const headerName in headers) {
                                headers[headerName] = stringInterpolator.parse(headers[headerName], interpolationData);
                            }
                            const requestInit = {
                                method,
                                headers,
                            };
                            const urlObj = new URL(fullPath);
                            const input = args.input;
                            if (input) {
                                switch (method) {
                                    case 'GET':
                                    case 'DELETE': {
                                        const newSearchParams = new URLSearchParams(input);
                                        newSearchParams.forEach((value, key) => {
                                            urlObj.searchParams.set(key, value);
                                        });
                                        break;
                                    }
                                    case 'POST':
                                    case 'PUT': {
                                        requestInit.body = JSON.stringify(input);
                                        break;
                                    }
                                    default:
                                        throw new Error(`Unknown method ${operationConfig.method}`);
                                }
                            }
                            const request = new Request(urlObj.toString(), requestInit);
                            const response = await fetchache(request, this.cache);
                            const responseText = await response.text();
                            let responseJson;
                            try {
                                responseJson = JSON.parse(responseText);
                            }
                            catch (e) {
                                throw responseText;
                            }
                            if (responseJson.errors) {
                                throw new AggregateError(responseJson.errors);
                            }
                            if (responseJson._errors) {
                                throw new AggregateError(responseJson._errors);
                            }
                            if (responseJson.error) {
                                throw responseJson.error;
                            }
                            return responseJson;
                        }
                    },
                },
            });
        };
        await Promise.all(typeNamedOperations.map(handleOperations));
        await Promise.all(unnamedOperations.map(handleOperations));
        const schema = schemaComposer.buildSchema();
        return {
            schema,
            contextVariables,
        };
    }
    async isGeneratedJSONSchemaValid({ samplePath, schemaPath }) {
        if (schemaPath || (!isUrl(schemaPath) && (await pathExists(schemaPath)))) {
            const [schemaFileStat, sampleFileStat] = await Promise.all([stat(schemaPath), stat(samplePath)]);
            if (schemaFileStat.mtime > sampleFileStat.mtime) {
                return true;
            }
        }
        return false;
    }
    async getValidCachedJSONSchema(samplePath) {
        const cachedSchema = await this.cache.get(samplePath);
        if (cachedSchema) {
            const sampleFileStat = await stat(samplePath);
            if (cachedSchema.timestamp > sampleFileStat.mtime.getTime()) {
                return cachedSchema.schema;
            }
            else {
                this.cache.delete(samplePath);
            }
        }
        return null;
    }
    async generateJsonSchemaFromSample({ samplePath, schemaPath }) {
        if (!(await this.isGeneratedJSONSchemaValid({ samplePath, schemaPath }))) {
            const cachedSample = await this.getValidCachedJSONSchema(samplePath);
            if (cachedSample) {
                return cachedSample;
            }
            const sample = await readFileOrUrlWithCache(samplePath, this.cache);
            const schema = toJsonSchema(sample, {
                required: false,
                objects: {
                    additionalProperties: false,
                },
                strings: {
                    detectFormat: true,
                },
                arrays: {
                    mode: 'first',
                },
            });
            if (schemaPath) {
                writeJSON(schemaPath, schema);
            }
            else {
                const cachedSchema = {
                    timestamp: Date.now(),
                    schema,
                };
                this.cache.set(samplePath, cachedSchema);
            }
            return schema;
        }
        return null;
    }
}

export default JsonSchemaHandler;
//# sourceMappingURL=index.esm.js.map
