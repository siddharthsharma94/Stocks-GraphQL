import { stitchSchemas } from '@graphql-tools/stitch';
import { wrapSchema } from '@graphql-tools/wrap';
import { extendSchema } from 'graphql';
import { addResolversToSchema } from '@graphql-tools/schema';
import { groupTransforms } from '@graphql-mesh/utils';
import { applySchemaTransforms } from '@graphql-tools/utils';

const mergeSingleSchema = ({ rawSources, typeDefs, resolvers, transforms }) => {
    if (rawSources.length !== 1) {
        throw new Error('This merger supports only one schema');
    }
    const [source] = rawSources;
    let schema = source.schema;
    let wrapTransforms = [];
    let noWrapTransforms = [];
    if (transforms === null || transforms === void 0 ? void 0 : transforms.length) {
        const transformGroups = groupTransforms(transforms);
        wrapTransforms = transformGroups.wrapTransforms;
        noWrapTransforms = transformGroups.noWrapTransforms;
    }
    if (source.executor || source.subscriber || source.transforms.length) {
        const firstRoundTransforms = [...source.transforms];
        if (!typeDefs && !resolvers) {
            firstRoundTransforms.push(...wrapTransforms, ...noWrapTransforms);
        }
        schema = wrapSchema({
            ...source,
            schema,
            transforms: firstRoundTransforms,
        });
    }
    if (typeDefs || resolvers) {
        typeDefs === null || typeDefs === void 0 ? void 0 : typeDefs.forEach(typeDef => {
            schema = extendSchema(schema, typeDef);
        });
        if (resolvers) {
            schema = addResolversToSchema({
                schema,
                resolvers,
                updateResolversInPlace: true,
            });
        }
        if (wrapTransforms.length) {
            schema = wrapSchema(schema, [...wrapTransforms, ...noWrapTransforms]);
        }
        else if (noWrapTransforms.length) {
            schema = applySchemaTransforms(schema, noWrapTransforms);
        }
    }
    schema.extensions = schema.extensions || {};
    Object.defineProperty(schema.extensions, 'sourceMap', {
        get: () => new Map([[source, schema]]),
    });
    return schema;
};

const mergeUsingStitching = async function (options) {
    if (options.rawSources.length === 1) {
        return mergeSingleSchema(options);
    }
    const { rawSources, typeDefs, resolvers, transforms } = options;
    let unifiedSchema = stitchSchemas({
        subschemas: rawSources,
        typeDefs,
        resolvers,
    });
    unifiedSchema.extensions = unifiedSchema.extensions || {};
    Object.defineProperty(unifiedSchema.extensions, 'sourceMap', {
        get: () => unifiedSchema.extensions.stitchingInfo.transformedSchemas,
    });
    if (transforms === null || transforms === void 0 ? void 0 : transforms.length) {
        const { noWrapTransforms, wrapTransforms } = groupTransforms(transforms);
        if (wrapTransforms.length) {
            unifiedSchema = wrapSchema({
                schema: unifiedSchema,
                batch: true,
                transforms: wrapTransforms,
            });
        }
        if (noWrapTransforms.length) {
            unifiedSchema = applySchemaTransforms(unifiedSchema, noWrapTransforms);
        }
    }
    return unifiedSchema;
};

export default mergeUsingStitching;
//# sourceMappingURL=index.esm.js.map
