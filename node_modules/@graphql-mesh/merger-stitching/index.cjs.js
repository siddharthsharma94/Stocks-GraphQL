'use strict';

const stitch = require('@graphql-tools/stitch');
const wrap = require('@graphql-tools/wrap');
const graphql = require('graphql');
const schema = require('@graphql-tools/schema');
const utils = require('@graphql-mesh/utils');
const utils$1 = require('@graphql-tools/utils');

const mergeSingleSchema = ({ rawSources, typeDefs, resolvers, transforms }) => {
    if (rawSources.length !== 1) {
        throw new Error('This merger supports only one schema');
    }
    const [source] = rawSources;
    let schema$1 = source.schema;
    let wrapTransforms = [];
    let noWrapTransforms = [];
    if (transforms === null || transforms === void 0 ? void 0 : transforms.length) {
        const transformGroups = utils.groupTransforms(transforms);
        wrapTransforms = transformGroups.wrapTransforms;
        noWrapTransforms = transformGroups.noWrapTransforms;
    }
    if (source.executor || source.subscriber || source.transforms.length) {
        const firstRoundTransforms = [...source.transforms];
        if (!typeDefs && !resolvers) {
            firstRoundTransforms.push(...wrapTransforms, ...noWrapTransforms);
        }
        schema$1 = wrap.wrapSchema({
            ...source,
            schema: schema$1,
            transforms: firstRoundTransforms,
        });
    }
    if (typeDefs || resolvers) {
        typeDefs === null || typeDefs === void 0 ? void 0 : typeDefs.forEach(typeDef => {
            schema$1 = graphql.extendSchema(schema$1, typeDef);
        });
        if (resolvers) {
            schema$1 = schema.addResolversToSchema({
                schema: schema$1,
                resolvers,
                updateResolversInPlace: true,
            });
        }
        if (wrapTransforms.length) {
            schema$1 = wrap.wrapSchema(schema$1, [...wrapTransforms, ...noWrapTransforms]);
        }
        else if (noWrapTransforms.length) {
            schema$1 = utils$1.applySchemaTransforms(schema$1, noWrapTransforms);
        }
    }
    schema$1.extensions = schema$1.extensions || {};
    Object.defineProperty(schema$1.extensions, 'sourceMap', {
        get: () => new Map([[source, schema$1]]),
    });
    return schema$1;
};

const mergeUsingStitching = async function (options) {
    if (options.rawSources.length === 1) {
        return mergeSingleSchema(options);
    }
    const { rawSources, typeDefs, resolvers, transforms } = options;
    let unifiedSchema = stitch.stitchSchemas({
        subschemas: rawSources,
        typeDefs,
        resolvers,
    });
    unifiedSchema.extensions = unifiedSchema.extensions || {};
    Object.defineProperty(unifiedSchema.extensions, 'sourceMap', {
        get: () => unifiedSchema.extensions.stitchingInfo.transformedSchemas,
    });
    if (transforms === null || transforms === void 0 ? void 0 : transforms.length) {
        const { noWrapTransforms, wrapTransforms } = utils.groupTransforms(transforms);
        if (wrapTransforms.length) {
            unifiedSchema = wrap.wrapSchema({
                schema: unifiedSchema,
                batch: true,
                transforms: wrapTransforms,
            });
        }
        if (noWrapTransforms.length) {
            unifiedSchema = utils$1.applySchemaTransforms(unifiedSchema, noWrapTransforms);
        }
    }
    return unifiedSchema;
};

module.exports = mergeUsingStitching;
//# sourceMappingURL=index.cjs.js.map
