import { MeshResolvedSource } from '@graphql-mesh/runtime';
import { YamlConfig } from '@graphql-mesh/types';
declare global {
    interface ObjectConstructor {
        keys<T>(obj: T): Array<keyof T>;
    }
}
export declare type ConfigProcessOptions = {
    dir?: string;
    ignoreAdditionalResolvers?: boolean;
    importFn?: (moduleId: string) => Promise<any>;
};
export declare function parseConfig(rawConfig: YamlConfig.Config | string, options?: {
    configFormat?: 'yaml' | 'json' | 'object';
} & ConfigProcessOptions): Promise<{
    sources: MeshResolvedSource<any>[];
    transforms: import("../../types/src").MeshTransform[];
    additionalTypeDefs: import("graphql").DocumentNode[];
    additionalResolvers: Record<string, import("@graphql-tools/utils").IUnionTypeResolver | import("@graphql-tools/utils").IScalarTypeResolver | import("@graphql-tools/utils").IEnumTypeResolver | import("@graphql-tools/utils").IInputObjectTypeResolver | import("@graphql-tools/utils").IFieldResolver<any, any, Record<string, any>, any> | import("@graphql-tools/utils").IObjectTypeResolver<any, any, any> | import("@graphql-tools/utils").IInterfaceTypeResolver<any, any, any>>;
    cache: import("fetchache").KeyValueCache<string>;
    merger: import("../../types/src").MergerFn;
    mergerType: string;
    pubsub: import("../../types/src").MeshPubSub;
    config: YamlConfig.Config;
}>;
export declare function processConfig(config: YamlConfig.Config, options?: ConfigProcessOptions): Promise<{
    sources: MeshResolvedSource<any>[];
    transforms: import("../../types/src").MeshTransform[];
    additionalTypeDefs: import("graphql").DocumentNode[];
    additionalResolvers: Record<string, import("@graphql-tools/utils").IUnionTypeResolver | import("@graphql-tools/utils").IScalarTypeResolver | import("@graphql-tools/utils").IEnumTypeResolver | import("@graphql-tools/utils").IInputObjectTypeResolver | import("@graphql-tools/utils").IFieldResolver<any, any, Record<string, any>, any> | import("@graphql-tools/utils").IObjectTypeResolver<any, any, any> | import("@graphql-tools/utils").IInterfaceTypeResolver<any, any, any>>;
    cache: import("fetchache").KeyValueCache<string>;
    merger: import("../../types/src").MergerFn;
    mergerType: string;
    pubsub: import("../../types/src").MeshPubSub;
    config: YamlConfig.Config;
}>;
export declare function validateConfig(config: any): asserts config is YamlConfig.Config;
export declare function findAndParseConfig(options?: {
    configName?: string;
} & ConfigProcessOptions): Promise<{
    sources: MeshResolvedSource<any>[];
    transforms: import("../../types/src").MeshTransform[];
    additionalTypeDefs: import("graphql").DocumentNode[];
    additionalResolvers: Record<string, import("@graphql-tools/utils").IUnionTypeResolver | import("@graphql-tools/utils").IScalarTypeResolver | import("@graphql-tools/utils").IEnumTypeResolver | import("@graphql-tools/utils").IInputObjectTypeResolver | import("@graphql-tools/utils").IFieldResolver<any, any, Record<string, any>, any> | import("@graphql-tools/utils").IObjectTypeResolver<any, any, any> | import("@graphql-tools/utils").IInterfaceTypeResolver<any, any, any>>;
    cache: import("fetchache").KeyValueCache<string>;
    merger: import("../../types/src").MergerFn;
    mergerType: string;
    pubsub: import("../../types/src").MeshPubSub;
    config: YamlConfig.Config;
}>;
