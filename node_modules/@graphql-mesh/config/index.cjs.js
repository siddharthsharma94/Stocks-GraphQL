'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

function _interopNamespace(e) {
    if (e && e.__esModule) { return e; } else {
        var n = {};
        if (e) {
            Object.keys(e).forEach(function (k) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            });
        }
        n['default'] = e;
        return n;
    }
}

const cosmiconfig = require('cosmiconfig');
const graphql = require('graphql');
const path = require('path');
const utils = require('@graphql-tools/utils');
const paramCase = require('param-case');
const load = require('@graphql-tools/load');
const graphqlFileLoader = require('@graphql-tools/graphql-file-loader');
const lodash = require('lodash');
const utils$1 = require('@graphql-mesh/utils');
const merge = require('@graphql-tools/merge');
const graphqlSubscriptions = require('graphql-subscriptions');
const events = require('events');
const types = require('@graphql-mesh/types');
const Ajv = _interopDefault(require('ajv'));

async function getPackage(name, type, importFn) {
    const casedName = paramCase.paramCase(name);
    const casedType = paramCase.paramCase(type);
    const possibleNames = [
        `@graphql-mesh/${casedName}`,
        `@graphql-mesh/${casedName}-${casedType}`,
        `@graphql-mesh/${casedType}-${casedName}`,
        casedName,
        `${casedName}-${casedType}`,
        `${casedType}-${casedName}`,
        casedType,
    ];
    if (name.includes('-')) {
        possibleNames.push(name);
    }
    const possibleModules = possibleNames.concat(path.resolve(process.cwd(), name));
    for (const moduleName of possibleModules) {
        try {
            const exported = await importFn(moduleName);
            return (exported.default || exported.parser || exported);
        }
        catch (err) {
            if (err.message.indexOf(`Cannot find module '${moduleName}'`) === -1) {
                throw new Error(`Unable to load ${type} matching ${name}: ${err.message}`);
            }
        }
    }
    throw new Error(`Unable to find ${type} matching ${name}`);
}
async function getHandler(name, importFn) {
    const handlerFn = await getPackage(name.toString(), 'handler', importFn);
    return handlerFn;
}
async function resolveAdditionalTypeDefs(baseDir, additionalTypeDefs) {
    if (additionalTypeDefs) {
        const sources = await load.loadTypedefs(additionalTypeDefs, {
            cwd: baseDir,
            loaders: [new graphqlFileLoader.GraphQLFileLoader()],
        });
        return sources.map(source => source.document || graphql.parse(source.rawSDL || utils.printSchemaWithDirectives(source.schema)));
    }
    return undefined;
}
async function resolveAdditionalResolvers(baseDir, additionalResolvers, importFn, pubsub) {
    const loadedResolvers = await Promise.all((additionalResolvers || []).map(async (additionalResolver) => {
        if (typeof additionalResolver === 'string') {
            const filePath = additionalResolver;
            const exported = await importFn(path.resolve(baseDir, filePath));
            let resolvers = null;
            if (exported.default) {
                if (exported.default.resolvers) {
                    resolvers = exported.default.resolvers;
                }
                else if (typeof exported.default === 'object') {
                    resolvers = exported.default;
                }
            }
            else if (exported.resolvers) {
                resolvers = exported.resolvers;
            }
            if (!resolvers) {
                console.warn(`Unable to load resolvers from file: ${filePath}`);
                return {};
            }
            return resolvers;
        }
        else {
            if ('pubsubTopic' in additionalResolver) {
                return {
                    [additionalResolver.type]: {
                        [additionalResolver.field]: {
                            subscribe: graphqlSubscriptions.withFilter((root, args, context, info) => {
                                const resolverData = { root, args, context, info };
                                const topic = utils$1.stringInterpolator.parse(additionalResolver.pubsubTopic, resolverData);
                                return pubsub.asyncIterator(topic);
                            }, (root, args, context, info) => {
                                return additionalResolver.filterBy ? eval(additionalResolver.filterBy) : true;
                            }),
                            resolve: (payload) => {
                                if (additionalResolver.returnData) {
                                    return lodash.get(payload, additionalResolver.returnData);
                                }
                                return payload;
                            },
                        },
                    },
                };
            }
            else {
                return {
                    [additionalResolver.type]: {
                        [additionalResolver.field]: {
                            selectionSet: additionalResolver.requiredSelectionSet,
                            resolve: async (root, args, context, info) => {
                                const resolverData = { root, args, context, info };
                                const methodArgs = {};
                                for (const argPath in additionalResolver.args) {
                                    lodash.set(methodArgs, argPath, utils$1.stringInterpolator.parse(additionalResolver.args[argPath], resolverData));
                                }
                                const result = await context[additionalResolver.targetSource].api[additionalResolver.targetMethod](methodArgs, {
                                    selectedFields: additionalResolver.resultSelectedFields,
                                    selectionSet: additionalResolver.resultSelectionSet,
                                    depth: additionalResolver.resultDepth,
                                });
                                return additionalResolver.returnData ? lodash.get(result, additionalResolver.returnData) : result;
                            },
                        },
                    },
                };
            }
        }
    }));
    return merge.mergeResolvers(loadedResolvers);
}
async function resolveCache(cacheConfig, importFn) {
    if (cacheConfig) {
        const cacheName = Object.keys(cacheConfig)[0];
        const config = cacheConfig[cacheName];
        const moduleName = lodash.kebabCase(cacheName.toString());
        const pkg = await getPackage(moduleName, 'cache', importFn);
        const Cache = pkg.default || pkg;
        return new Cache(config);
    }
    const InMemoryLRUCache = await new Promise(function (resolve) { resolve(_interopNamespace(require('@graphql-mesh/cache-inmemory-lru'))); }).then(m => m.default);
    const cache = new InMemoryLRUCache();
    return cache;
}
async function resolvePubSub(pubsubYamlConfig, importFn) {
    if (pubsubYamlConfig) {
        let pubsubName;
        let pubsubConfig;
        if (typeof pubsubYamlConfig === 'string') {
            pubsubName = pubsubYamlConfig;
        }
        else {
            pubsubName = pubsubYamlConfig.name;
            pubsubConfig = pubsubYamlConfig.config;
        }
        const moduleName = lodash.kebabCase(pubsubName.toString());
        const pkg = await getPackage(moduleName, 'pubsub', importFn);
        const PubSub = pkg.default || pkg;
        return new PubSub(pubsubConfig);
    }
    else {
        const eventEmitter = new events.EventEmitter({ captureRejections: true });
        eventEmitter.setMaxListeners(Infinity);
        const pubsub = new graphqlSubscriptions.PubSub({ eventEmitter });
        return pubsub;
    }
}
async function resolveMerger(mergerConfig, importFn) {
    if (mergerConfig) {
        const pkg = await getPackage(mergerConfig, 'merger', importFn);
        return pkg.default || pkg;
    }
    const StitchingMerger = await new Promise(function (resolve) { resolve(_interopNamespace(require('@graphql-mesh/merger-stitching'))); }).then(m => m.default);
    return StitchingMerger;
}

async function parseConfig(rawConfig, options) {
    let config;
    const { configFormat = 'object' } = options || {};
    switch (configFormat) {
        case 'yaml':
            config = cosmiconfig.defaultLoaders['.yaml']('.meshrc.yml', rawConfig);
            break;
        case 'json':
            config = cosmiconfig.defaultLoaders['.json']('.meshrc.json', rawConfig);
            break;
        case 'object':
            config = rawConfig;
            break;
    }
    return processConfig(config, options);
}
async function processConfig(config, options) {
    var _a, _b;
    const { dir = process.cwd(), ignoreAdditionalResolvers = false, importFn = (moduleId) => new Promise(function (resolve) { resolve(_interopNamespace(require(moduleId))); }) } = options || {};
    await Promise.all(((_a = config.require) === null || _a === void 0 ? void 0 : _a.map(mod => importFn(mod))) || []);
    const cache = await resolveCache(config.cache, importFn);
    const pubsub = await resolvePubSub(config.pubsub, importFn);
    const [sources, transforms, additionalTypeDefs, additionalResolvers, merger] = await Promise.all([
        Promise.all(config.sources.map(async (source) => {
            const handlerName = Object.keys(source.handler)[0];
            const handlerConfig = source.handler[handlerName];
            const [handlerLibrary, transforms] = await Promise.all([
                getHandler(handlerName, importFn),
                Promise.all((source.transforms || []).map(async (t) => {
                    const transformName = Object.keys(t)[0];
                    const transformConfig = t[transformName];
                    const TransformCtor = await getPackage(transformName.toString(), 'transform', importFn);
                    return new TransformCtor({
                        apiName: source.name,
                        config: transformConfig,
                        cache,
                        pubsub,
                    });
                })),
            ]);
            const HandlerCtor = handlerLibrary;
            return {
                name: source.name,
                handler: new HandlerCtor({
                    name: source.name,
                    cache,
                    pubsub,
                    config: handlerConfig,
                }),
                transforms,
            };
        })),
        Promise.all(((_b = config.transforms) === null || _b === void 0 ? void 0 : _b.map(async (t) => {
            const transformName = Object.keys(t)[0];
            const transformConfig = t[transformName];
            const TransformLibrary = await getPackage(transformName.toString(), 'transform', importFn);
            return new TransformLibrary({
                apiName: '',
                cache,
                pubsub,
                config: transformConfig,
            });
        })) || []),
        resolveAdditionalTypeDefs(dir, config.additionalTypeDefs),
        resolveAdditionalResolvers(dir, ignoreAdditionalResolvers ? [] : config.additionalResolvers || [], importFn, pubsub),
        resolveMerger(config.merger, importFn),
    ]);
    return {
        sources,
        transforms,
        additionalTypeDefs,
        additionalResolvers,
        cache,
        merger,
        mergerType: config.merger,
        pubsub,
        config,
    };
}
function customLoader(ext) {
    function loader(filepath, content) {
        if (typeof process !== 'undefined' && 'env' in process) {
            content = content.replace(/\$\{(.*?)\}/g, (_, variable) => {
                let varName = variable;
                let defaultValue = '';
                if (variable.includes(':')) {
                    const spl = variable.split(':');
                    varName = spl.shift();
                    defaultValue = spl.join(':');
                }
                return process.env[varName] || defaultValue;
            });
        }
        if (ext === 'json') {
            return cosmiconfig.defaultLoaders['.json'](filepath, content);
        }
        if (ext === 'yaml') {
            return cosmiconfig.defaultLoaders['.yaml'](filepath, content);
        }
        if (ext === 'js') {
            return cosmiconfig.defaultLoaders['.js'](filepath, content);
        }
    }
    return loader;
}
function validateConfig(config) {
    const ajv = new Ajv({ schemaId: 'auto' });
    // Settings for draft-04
    const metaSchema = require('ajv/lib/refs/json-schema-draft-04.json');
    ajv.addMetaSchema(metaSchema);
    const isValid = ajv.validate(types.getJsonSchema(), config);
    if (!isValid) {
        console.warn(`GraphQL Mesh Configuration is not valid:\n${ajv.errorsText()}`);
    }
}
async function findAndParseConfig(options) {
    const { configName = 'mesh', dir = process.cwd(), ignoreAdditionalResolvers = false } = options || {};
    const explorer = cosmiconfig.cosmiconfig(configName, {
        loaders: {
            '.json': customLoader('json'),
            '.yaml': customLoader('yaml'),
            '.yml': customLoader('yaml'),
            '.js': customLoader('js'),
            noExt: customLoader('yaml'),
        },
    });
    const results = await explorer.search(dir);
    const config = results.config;
    validateConfig(config);
    return processConfig(config, { dir, ignoreAdditionalResolvers });
}

exports.findAndParseConfig = findAndParseConfig;
exports.parseConfig = parseConfig;
exports.processConfig = processConfig;
exports.validateConfig = validateConfig;
//# sourceMappingURL=index.cjs.js.map
