import { defaultLoaders, cosmiconfig } from 'cosmiconfig';
import { parse } from 'graphql';
import { resolve } from 'path';
import { printSchemaWithDirectives } from '@graphql-tools/utils';
import { paramCase } from 'param-case';
import { loadTypedefs } from '@graphql-tools/load';
import { GraphQLFileLoader } from '@graphql-tools/graphql-file-loader';
import { get, set, kebabCase } from 'lodash';
import { stringInterpolator } from '@graphql-mesh/utils';
import { mergeResolvers } from '@graphql-tools/merge';
import { withFilter, PubSub } from 'graphql-subscriptions';
import { EventEmitter } from 'events';
import { getJsonSchema } from '@graphql-mesh/types';
import Ajv from 'ajv';

async function getPackage(name, type, importFn) {
    const casedName = paramCase(name);
    const casedType = paramCase(type);
    const possibleNames = [
        `@graphql-mesh/${casedName}`,
        `@graphql-mesh/${casedName}-${casedType}`,
        `@graphql-mesh/${casedType}-${casedName}`,
        casedName,
        `${casedName}-${casedType}`,
        `${casedType}-${casedName}`,
        casedType,
    ];
    if (name.includes('-')) {
        possibleNames.push(name);
    }
    const possibleModules = possibleNames.concat(resolve(process.cwd(), name));
    for (const moduleName of possibleModules) {
        try {
            const exported = await importFn(moduleName);
            return (exported.default || exported.parser || exported);
        }
        catch (err) {
            if (err.message.indexOf(`Cannot find module '${moduleName}'`) === -1) {
                throw new Error(`Unable to load ${type} matching ${name}: ${err.message}`);
            }
        }
    }
    throw new Error(`Unable to find ${type} matching ${name}`);
}
async function getHandler(name, importFn) {
    const handlerFn = await getPackage(name.toString(), 'handler', importFn);
    return handlerFn;
}
async function resolveAdditionalTypeDefs(baseDir, additionalTypeDefs) {
    if (additionalTypeDefs) {
        const sources = await loadTypedefs(additionalTypeDefs, {
            cwd: baseDir,
            loaders: [new GraphQLFileLoader()],
        });
        return sources.map(source => source.document || parse(source.rawSDL || printSchemaWithDirectives(source.schema)));
    }
    return undefined;
}
async function resolveAdditionalResolvers(baseDir, additionalResolvers, importFn, pubsub) {
    const loadedResolvers = await Promise.all((additionalResolvers || []).map(async (additionalResolver) => {
        if (typeof additionalResolver === 'string') {
            const filePath = additionalResolver;
            const exported = await importFn(resolve(baseDir, filePath));
            let resolvers = null;
            if (exported.default) {
                if (exported.default.resolvers) {
                    resolvers = exported.default.resolvers;
                }
                else if (typeof exported.default === 'object') {
                    resolvers = exported.default;
                }
            }
            else if (exported.resolvers) {
                resolvers = exported.resolvers;
            }
            if (!resolvers) {
                console.warn(`Unable to load resolvers from file: ${filePath}`);
                return {};
            }
            return resolvers;
        }
        else {
            if ('pubsubTopic' in additionalResolver) {
                return {
                    [additionalResolver.type]: {
                        [additionalResolver.field]: {
                            subscribe: withFilter((root, args, context, info) => {
                                const resolverData = { root, args, context, info };
                                const topic = stringInterpolator.parse(additionalResolver.pubsubTopic, resolverData);
                                return pubsub.asyncIterator(topic);
                            }, (root, args, context, info) => {
                                return additionalResolver.filterBy ? eval(additionalResolver.filterBy) : true;
                            }),
                            resolve: (payload) => {
                                if (additionalResolver.returnData) {
                                    return get(payload, additionalResolver.returnData);
                                }
                                return payload;
                            },
                        },
                    },
                };
            }
            else {
                return {
                    [additionalResolver.type]: {
                        [additionalResolver.field]: {
                            selectionSet: additionalResolver.requiredSelectionSet,
                            resolve: async (root, args, context, info) => {
                                const resolverData = { root, args, context, info };
                                const methodArgs = {};
                                for (const argPath in additionalResolver.args) {
                                    set(methodArgs, argPath, stringInterpolator.parse(additionalResolver.args[argPath], resolverData));
                                }
                                const result = await context[additionalResolver.targetSource].api[additionalResolver.targetMethod](methodArgs, {
                                    selectedFields: additionalResolver.resultSelectedFields,
                                    selectionSet: additionalResolver.resultSelectionSet,
                                    depth: additionalResolver.resultDepth,
                                });
                                return additionalResolver.returnData ? get(result, additionalResolver.returnData) : result;
                            },
                        },
                    },
                };
            }
        }
    }));
    return mergeResolvers(loadedResolvers);
}
async function resolveCache(cacheConfig, importFn) {
    if (cacheConfig) {
        const cacheName = Object.keys(cacheConfig)[0];
        const config = cacheConfig[cacheName];
        const moduleName = kebabCase(cacheName.toString());
        const pkg = await getPackage(moduleName, 'cache', importFn);
        const Cache = pkg.default || pkg;
        return new Cache(config);
    }
    const InMemoryLRUCache = await import('@graphql-mesh/cache-inmemory-lru').then(m => m.default);
    const cache = new InMemoryLRUCache();
    return cache;
}
async function resolvePubSub(pubsubYamlConfig, importFn) {
    if (pubsubYamlConfig) {
        let pubsubName;
        let pubsubConfig;
        if (typeof pubsubYamlConfig === 'string') {
            pubsubName = pubsubYamlConfig;
        }
        else {
            pubsubName = pubsubYamlConfig.name;
            pubsubConfig = pubsubYamlConfig.config;
        }
        const moduleName = kebabCase(pubsubName.toString());
        const pkg = await getPackage(moduleName, 'pubsub', importFn);
        const PubSub = pkg.default || pkg;
        return new PubSub(pubsubConfig);
    }
    else {
        const eventEmitter = new EventEmitter({ captureRejections: true });
        eventEmitter.setMaxListeners(Infinity);
        const pubsub = new PubSub({ eventEmitter });
        return pubsub;
    }
}
async function resolveMerger(mergerConfig, importFn) {
    if (mergerConfig) {
        const pkg = await getPackage(mergerConfig, 'merger', importFn);
        return pkg.default || pkg;
    }
    const StitchingMerger = await import('@graphql-mesh/merger-stitching').then(m => m.default);
    return StitchingMerger;
}

async function parseConfig(rawConfig, options) {
    let config;
    const { configFormat = 'object' } = options || {};
    switch (configFormat) {
        case 'yaml':
            config = defaultLoaders['.yaml']('.meshrc.yml', rawConfig);
            break;
        case 'json':
            config = defaultLoaders['.json']('.meshrc.json', rawConfig);
            break;
        case 'object':
            config = rawConfig;
            break;
    }
    return processConfig(config, options);
}
async function processConfig(config, options) {
    var _a, _b;
    const { dir = process.cwd(), ignoreAdditionalResolvers = false, importFn = (moduleId) => import(moduleId) } = options || {};
    await Promise.all(((_a = config.require) === null || _a === void 0 ? void 0 : _a.map(mod => importFn(mod))) || []);
    const cache = await resolveCache(config.cache, importFn);
    const pubsub = await resolvePubSub(config.pubsub, importFn);
    const [sources, transforms, additionalTypeDefs, additionalResolvers, merger] = await Promise.all([
        Promise.all(config.sources.map(async (source) => {
            const handlerName = Object.keys(source.handler)[0];
            const handlerConfig = source.handler[handlerName];
            const [handlerLibrary, transforms] = await Promise.all([
                getHandler(handlerName, importFn),
                Promise.all((source.transforms || []).map(async (t) => {
                    const transformName = Object.keys(t)[0];
                    const transformConfig = t[transformName];
                    const TransformCtor = await getPackage(transformName.toString(), 'transform', importFn);
                    return new TransformCtor({
                        apiName: source.name,
                        config: transformConfig,
                        cache,
                        pubsub,
                    });
                })),
            ]);
            const HandlerCtor = handlerLibrary;
            return {
                name: source.name,
                handler: new HandlerCtor({
                    name: source.name,
                    cache,
                    pubsub,
                    config: handlerConfig,
                }),
                transforms,
            };
        })),
        Promise.all(((_b = config.transforms) === null || _b === void 0 ? void 0 : _b.map(async (t) => {
            const transformName = Object.keys(t)[0];
            const transformConfig = t[transformName];
            const TransformLibrary = await getPackage(transformName.toString(), 'transform', importFn);
            return new TransformLibrary({
                apiName: '',
                cache,
                pubsub,
                config: transformConfig,
            });
        })) || []),
        resolveAdditionalTypeDefs(dir, config.additionalTypeDefs),
        resolveAdditionalResolvers(dir, ignoreAdditionalResolvers ? [] : config.additionalResolvers || [], importFn, pubsub),
        resolveMerger(config.merger, importFn),
    ]);
    return {
        sources,
        transforms,
        additionalTypeDefs,
        additionalResolvers,
        cache,
        merger,
        mergerType: config.merger,
        pubsub,
        config,
    };
}
function customLoader(ext) {
    function loader(filepath, content) {
        if (typeof process !== 'undefined' && 'env' in process) {
            content = content.replace(/\$\{(.*?)\}/g, (_, variable) => {
                let varName = variable;
                let defaultValue = '';
                if (variable.includes(':')) {
                    const spl = variable.split(':');
                    varName = spl.shift();
                    defaultValue = spl.join(':');
                }
                return process.env[varName] || defaultValue;
            });
        }
        if (ext === 'json') {
            return defaultLoaders['.json'](filepath, content);
        }
        if (ext === 'yaml') {
            return defaultLoaders['.yaml'](filepath, content);
        }
        if (ext === 'js') {
            return defaultLoaders['.js'](filepath, content);
        }
    }
    return loader;
}
function validateConfig(config) {
    const ajv = new Ajv({ schemaId: 'auto' });
    // Settings for draft-04
    const metaSchema = require('ajv/lib/refs/json-schema-draft-04.json');
    ajv.addMetaSchema(metaSchema);
    const isValid = ajv.validate(getJsonSchema(), config);
    if (!isValid) {
        console.warn(`GraphQL Mesh Configuration is not valid:\n${ajv.errorsText()}`);
    }
}
async function findAndParseConfig(options) {
    const { configName = 'mesh', dir = process.cwd(), ignoreAdditionalResolvers = false } = options || {};
    const explorer = cosmiconfig(configName, {
        loaders: {
            '.json': customLoader('json'),
            '.yaml': customLoader('yaml'),
            '.yml': customLoader('yaml'),
            '.js': customLoader('js'),
            noExt: customLoader('yaml'),
        },
    });
    const results = await explorer.search(dir);
    const config = results.config;
    validateConfig(config);
    return processConfig(config, { dir, ignoreAdditionalResolvers });
}

export { findAndParseConfig, parseConfig, processConfig, validateConfig };
//# sourceMappingURL=index.esm.js.map
