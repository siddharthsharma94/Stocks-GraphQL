import { parse, print, Kind, execute, subscribe } from 'graphql';
import { composeResolvers } from '@graphql-tools/resolvers-composition';
import { buildOperationNodeForField, applySchemaTransforms } from '@graphql-tools/utils';
import { addResolversToSchema } from '@graphql-tools/schema';
import { delegateToSchema } from '@graphql-tools/delegate';
import { extractResolvers, groupTransforms, ensureDocumentNode } from '@graphql-mesh/utils';

const MESH_CONTEXT_SYMBOL = Symbol('isMeshContext');
const MESH_API_CONTEXT_SYMBOL = Symbol('isMeshAPIContext');

function isMeshContext(context) {
    return !!context && typeof context === 'object' && MESH_CONTEXT_SYMBOL in context;
}
function isAPIContext(apiContext) {
    return !!apiContext && typeof apiContext === 'object' && MESH_API_CONTEXT_SYMBOL in apiContext;
}
function createProxyInfo({ schema, parentType, field, depthLimit = 2, root, args, selectedFields, selectionSet, operationKind, info, }) {
    const actualReturnType = 'ofType' in info.returnType ? info.returnType.ofType : info.returnType;
    const returnType = 'ofType' in field.type ? field.type.ofType : field.type;
    if (!selectedFields &&
        !selectionSet &&
        'name' in actualReturnType &&
        'name' in returnType &&
        actualReturnType.name === returnType.name) {
        return {
            ...info,
            returnType,
        };
    }
    selectionSet = selectionSet && (typeof selectionSet === 'string' ? parse(selectionSet) : parse(print(selectionSet)));
    const operation = (selectionSet === null || selectionSet === void 0 ? void 0 : selectionSet.definitions[0]) ||
        buildOperationNodeForField({
            schema,
            kind: operationKind,
            field: field.name,
            depthLimit,
            argNames: Object.keys(args),
            selectedFields,
        });
    return {
        fieldName: field.name,
        fieldNodes: operation.selectionSet.selections.filter(s => s.kind === Kind.FIELD),
        returnType: field.type,
        parentType,
        schema,
        fragments: {},
        rootValue: root,
        operation,
        variableValues: args,
        path: {
            key: field.name,
        },
    };
}
function applyResolversHooksToResolvers(unifiedSchema, resolvers, pubsub) {
    var _a;
    // TODO: We should find another way to map schema with rawSources
    const nameSchemaMap = new Map();
    if ((_a = unifiedSchema.extensions) === null || _a === void 0 ? void 0 : _a.sourceMap) {
        for (const [rawSource, schema] of unifiedSchema.extensions.sourceMap.entries()) {
            nameSchemaMap.set(rawSource.name, schema);
        }
    }
    return composeResolvers(resolvers, {
        '*.*': originalResolver => async (root, args, context = {}, info) => {
            const resolverData = {
                root,
                args,
                context,
                info,
            };
            pubsub.publish('resolverCalled', { resolverData });
            try {
                const proxyContext = new Proxy(context, {
                    get(context, apiName) {
                        if (isMeshContext(context)) {
                            const apiContext = context[apiName];
                            if (isAPIContext(apiContext)) {
                                return {
                                    ...apiContext,
                                    api: getSdk(apiContext, nameSchemaMap, info, root, context, 'all'),
                                    apiQuery: getSdk(apiContext, nameSchemaMap, info, root, context, 'query'),
                                    apiMutation: getSdk(apiContext, nameSchemaMap, info, root, context, 'mutation'),
                                    apiSubscription: getSdk(apiContext, nameSchemaMap, info, root, context, 'subscription'),
                                };
                            }
                        }
                        return context[apiName];
                    },
                });
                const result = await originalResolver(root, args, proxyContext, info);
                pubsub.publish('resolverDone', { resolverData, result });
                return result;
            }
            catch (error) {
                pubsub.publish('resolverError', { resolverData, error });
                throw error;
            }
        },
    });
}
function getSdk(apiContext, nameSchemaMap, info, root, context, focusOnRootType) {
    return new Proxy(apiContext, {
        get(apiContext, fieldName) {
            const apiSchema = nameSchemaMap.get(apiContext.rawSource.name);
            let rootTypes = { query: null, mutation: null, subscription: null };
            switch (focusOnRootType) {
                case 'query':
                    rootTypes = {
                        query: apiSchema.getQueryType(),
                        mutation: null,
                        subscription: null,
                    };
                    break;
                case 'mutation':
                    rootTypes = {
                        query: null,
                        mutation: apiSchema.getMutationType(),
                        subscription: null,
                    };
                    break;
                case 'subscription':
                    rootTypes = {
                        query: null,
                        mutation: null,
                        subscription: apiSchema.getSubscriptionType(),
                    };
                    break;
                default:
                    rootTypes = {
                        query: apiSchema.getQueryType(),
                        mutation: apiSchema.getMutationType(),
                        subscription: apiSchema.getSubscriptionType(),
                    };
                    break;
            }
            let parentType;
            let operation;
            let field;
            for (const operationName in rootTypes) {
                const rootType = rootTypes[operationName];
                if (rootType) {
                    const fieldMap = rootType.getFields();
                    if (fieldName in fieldMap) {
                        operation = operationName;
                        field = fieldMap[fieldName];
                        parentType = rootType;
                        // TODO: There might be collision here between the same field names in different root types
                        // JYC Fix: collision only in 'all' mode, not in other modes
                        if (operation === info.operation.operation) {
                            break;
                        }
                    }
                }
            }
            return (methodArgs = {}, { depth, fields, selectionSet } = {}) => {
                const proxyInfo = createProxyInfo({
                    schema: apiSchema,
                    parentType,
                    field,
                    depthLimit: depth,
                    root,
                    args: methodArgs,
                    selectedFields: fields,
                    selectionSet,
                    info,
                    operationKind: operation,
                });
                return delegateToSchema({
                    schema: apiSchema,
                    operation,
                    fieldName,
                    args: methodArgs,
                    context,
                    info: proxyInfo,
                });
            };
        },
    });
}
function applyResolversHooksToSchema(schema, pubsub) {
    const sourceResolvers = extractResolvers(schema);
    return addResolversToSchema({
        schema,
        resolvers: applyResolversHooksToResolvers(schema, sourceResolvers, pubsub),
        updateResolversInPlace: true,
    });
}

/* eslint-disable no-unused-expressions */
async function getMesh(options) {
    const rawSources = [];
    const { pubsub, cache } = options;
    await Promise.all(options.sources.map(async (apiSource) => {
        const source = await apiSource.handler.getMeshSource();
        let apiSchema = source.schema;
        const apiName = apiSource.name;
        const { wrapTransforms, noWrapTransforms } = groupTransforms(apiSource.transforms);
        // If schema is going to be wrapped already we can use noWrapTransforms as wrapTransforms on source level
        // The idea behind avoiding wrapping as much as possible is to decrease multiple rounds of graphqljs execution phase for performance
        if (wrapTransforms.length === 0 && !source.executor && !source.subscriber) {
            apiSchema = applySchemaTransforms(apiSchema, noWrapTransforms);
        }
        else {
            wrapTransforms.push(...noWrapTransforms);
        }
        rawSources.push({
            name: apiName,
            contextBuilder: source.contextBuilder || null,
            schema: apiSchema,
            executor: source.executor,
            subscriber: source.subscriber,
            transforms: wrapTransforms,
            contextVariables: source.contextVariables || [],
            handler: apiSource.handler,
            batch: 'batch' in source ? source.batch : true,
        });
    }));
    let unifiedSchema = await options.merger({
        rawSources,
        cache,
        pubsub,
        typeDefs: options.additionalTypeDefs,
        resolvers: options.additionalResolvers,
        transforms: options.transforms,
    });
    unifiedSchema = applyResolversHooksToSchema(unifiedSchema, pubsub);
    async function buildMeshContext(initialContextValue) {
        const context = {
            ...initialContextValue,
            pubsub,
            [MESH_CONTEXT_SYMBOL]: true,
        };
        await Promise.all(rawSources.map(async (rawSource) => {
            const contextBuilder = rawSource.contextBuilder;
            if (contextBuilder) {
                const sourceContext = await contextBuilder(context);
                if (sourceContext) {
                    Object.assign(context, sourceContext);
                }
            }
            Object.assign(context, {
                [rawSource.name]: {
                    rawSource,
                    [MESH_API_CONTEXT_SYMBOL]: true,
                },
            });
        }));
        return context;
    }
    async function meshExecute(document, variables, context, rootValue) {
        const contextValue = await buildMeshContext(context);
        return execute({
            document: ensureDocumentNode(document),
            contextValue,
            rootValue: rootValue || {},
            variableValues: variables || {},
            schema: unifiedSchema,
        });
    }
    async function meshSubscribe(document, variables, context, rootValue) {
        const contextValue = await buildMeshContext(context);
        return subscribe({
            document: ensureDocumentNode(document),
            contextValue,
            rootValue: rootValue || {},
            variableValues: variables || {},
            schema: unifiedSchema,
        });
    }
    const localRequester = async (document, variables, context) => {
        const executionResult = await meshExecute(document, variables, context);
        if (executionResult.data && !executionResult.errors) {
            return executionResult.data;
        }
        else {
            throw new GraphQLMeshSdkError(executionResult.errors, document, variables, executionResult.data);
        }
    };
    return {
        execute: meshExecute,
        subscribe: meshSubscribe,
        schema: unifiedSchema,
        contextBuilder: buildMeshContext,
        rawSources,
        sdkRequester: localRequester,
        cache,
        pubsub,
        destroy: () => pubsub.publish('destroy', undefined),
    };
}
class GraphQLMeshSdkError extends Error {
    constructor(errors, document, variables, data) {
        super(`GraphQL Mesh SDK Failed (${errors.length} errors): ${errors.map(e => e.message).join('\n\t')}`);
        this.errors = errors;
        this.document = document;
        this.variables = variables;
        this.data = data;
        errors.forEach(e => console.error(e));
    }
}

export { GraphQLMeshSdkError, applyResolversHooksToResolvers, applyResolversHooksToSchema, getMesh };
//# sourceMappingURL=index.esm.js.map
