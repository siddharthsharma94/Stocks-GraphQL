'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const CachePolicy = _interopDefault(require('http-cache-semantics'));
const crossFetch = require('cross-fetch');

async function fetchache(request, cache) {
    const cacheKey = request.url;
    const entry = await cache.get(cacheKey);
    if (!entry) {
        const response = await crossFetch.fetch(request);
        const policy = new CachePolicy(policyRequestFrom(request), policyResponseFrom(response));
        return storeResponseAndReturnClone(cache, response, policy, cacheKey);
    }
    const { policy: policyRaw, body } = JSON.parse(entry);
    const policy = CachePolicy.fromObject(policyRaw);
    // Remove url from the policy, because otherwise it would never match a request with a custom cache key
    policy._url = undefined;
    if (policy.satisfiesWithoutRevalidation(policyRequestFrom(request))) {
        const headers = policy.responseHeaders();
        return new crossFetch.Response(body, {
            url: policy._url,
            status: policy._status,
            headers,
        });
    }
    else {
        const revalidationHeaders = policy.revalidationHeaders(policyRequestFrom(request));
        const revalidationRequest = new crossFetch.Request(request, {
            headers: revalidationHeaders,
        });
        const revalidationResponse = await crossFetch.fetch(revalidationRequest);
        const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(policyRequestFrom(revalidationRequest), policyResponseFrom(revalidationResponse));
        return storeResponseAndReturnClone(cache, new crossFetch.Response(modified ? await revalidationResponse.text() : body, {
            url: revalidatedPolicy._url,
            status: revalidatedPolicy._status,
            headers: revalidatedPolicy.responseHeaders(),
        }), revalidatedPolicy, cacheKey);
    }
}
async function storeResponseAndReturnClone(cache, response, policy, cacheKey) {
    let ttl = Math.round(policy.timeToLive() / 1000);
    if (ttl <= 0)
        return response;
    // If a response can be revalidated, we don't want to remove it from the cache right after it expires.
    // We may be able to use better heuristics here, but for now we'll take the max-age times 2.
    if (canBeRevalidated(response)) {
        ttl *= 2;
    }
    const body = await response.text();
    const entry = JSON.stringify({
        policy: policy.toObject(),
        body,
    });
    await cache.set(cacheKey, entry, {
        ttl,
    });
    // We have to clone the response before returning it because the
    // body can only be used once.
    // To avoid https://github.com/bitinn/node-fetch/issues/151, we don't use
    // response.clone() but create a new response from the consumed body
    return new crossFetch.Response(body, {
        url: response.url,
        status: response.status,
        statusText: response.statusText,
        headers: response.headers,
    });
}
function canBeRevalidated(response) {
    return response.headers.has('ETag');
}
function policyRequestFrom(request) {
    return {
        url: request.url,
        method: request.method,
        headers: headersToObject(request.headers),
    };
}
function policyResponseFrom(response) {
    return {
        status: response.status,
        headers: headersToObject(response.headers),
    };
}
function headersToObject(headers) {
    const object = Object.create(null);
    headers.forEach((val, key) => {
        object[key] = val;
    });
    return object;
}

Object.keys(crossFetch).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return crossFetch[k];
        }
    });
});
exports.default = fetchache;
exports.fetchache = fetchache;
//# sourceMappingURL=index.cjs.js.map
