{"version":3,"file":"index.cjs.js","sources":["../src/index.ts"],"sourcesContent":["import CachePolicy from 'http-cache-semantics';\r\nimport { fetch, Request, Response } from 'cross-fetch';\r\n\r\nexport async function fetchache(request: Request, cache: KeyValueCache) {\r\n    const cacheKey = request.url;\r\n    const entry = await cache.get(cacheKey);\r\n    if (!entry) {\r\n        const response = await fetch(request);\r\n\r\n        const policy = new CachePolicy(\r\n            policyRequestFrom(request),\r\n            policyResponseFrom(response),\r\n        );\r\n\r\n        return storeResponseAndReturnClone(\r\n            cache,\r\n            response,\r\n            policy,\r\n            cacheKey,\r\n        );\r\n    }\r\n\r\n    const { policy: policyRaw, body } = JSON.parse(entry);\r\n\r\n    const policy = CachePolicy.fromObject(policyRaw);\r\n    // Remove url from the policy, because otherwise it would never match a request with a custom cache key\r\n    (policy as any)._url = undefined;\r\n\r\n    if (policy.satisfiesWithoutRevalidation(policyRequestFrom(request))) {\r\n        const headers = policy.responseHeaders() as HeadersInit;\r\n        return new Response(body, {\r\n            url: (policy as any)._url,\r\n            status: (policy as any)._status,\r\n            headers,\r\n        } as ResponseInit);\r\n    } else {\r\n        const revalidationHeaders = policy.revalidationHeaders(\r\n            policyRequestFrom(request),\r\n        );\r\n        const revalidationRequest = new Request(request, {\r\n            headers: revalidationHeaders as HeadersInit,\r\n        });\r\n        const revalidationResponse = await fetch(revalidationRequest);\r\n\r\n        const { policy: revalidatedPolicy, modified } = policy.revalidatedPolicy(\r\n            policyRequestFrom(revalidationRequest),\r\n            policyResponseFrom(revalidationResponse),\r\n        );\r\n\r\n        return storeResponseAndReturnClone(\r\n            cache,\r\n            new Response(modified ? await revalidationResponse.text() : body, {\r\n                url: (revalidatedPolicy as any)._url,\r\n                status: (revalidatedPolicy as any)._status,\r\n                headers: (revalidatedPolicy as any).responseHeaders(),\r\n            } as ResponseInit),\r\n            revalidatedPolicy,\r\n            cacheKey,\r\n        );\r\n    }\r\n}\r\n\r\nexport * from 'cross-fetch';\r\n\r\nexport default fetchache;\r\n\r\nasync function storeResponseAndReturnClone(\r\n    cache: KeyValueCache,\r\n    response: Response,\r\n    policy: CachePolicy,\r\n    cacheKey: string,\r\n): Promise<Response> {\r\n\r\n    let ttl = Math.round(policy.timeToLive() / 1000);\r\n    if (ttl <= 0) return response;\r\n\r\n    // If a response can be revalidated, we don't want to remove it from the cache right after it expires.\r\n    // We may be able to use better heuristics here, but for now we'll take the max-age times 2.\r\n    if (canBeRevalidated(response)) {\r\n        ttl *= 2;\r\n    }\r\n\r\n    const body = await response.text();\r\n    const entry = JSON.stringify({\r\n        policy: policy.toObject(),\r\n        body,\r\n    });\r\n\r\n    await cache.set(cacheKey, entry, {\r\n        ttl,\r\n    });\r\n\r\n    // We have to clone the response before returning it because the\r\n    // body can only be used once.\r\n    // To avoid https://github.com/bitinn/node-fetch/issues/151, we don't use\r\n    // response.clone() but create a new response from the consumed body\r\n    return new Response(body, {\r\n        url: response.url,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        headers: response.headers,\r\n    } as ResponseInit);\r\n}\r\n\r\nfunction canBeRevalidated(response: Response): boolean {\r\n    return response.headers.has('ETag');\r\n}\r\n\r\nfunction policyRequestFrom(request: Request) {\r\n    return {\r\n        url: request.url,\r\n        method: request.method,\r\n        headers: headersToObject(request.headers),\r\n    };\r\n}\r\n\r\nfunction policyResponseFrom(response: Response) {\r\n    return {\r\n        status: response.status,\r\n        headers: headersToObject(response.headers),\r\n    };\r\n}\r\n\r\nfunction headersToObject(headers: Headers) {\r\n    const object = Object.create(null);\r\n    headers.forEach((val, key) => {\r\n        object[key] = val;\r\n    });\r\n    return object;\r\n}\r\n\r\nexport interface KeyValueCacheSetOptions {\r\n    /**\r\n     * Specified in **seconds**, the time-to-live (TTL) value limits the lifespan\r\n     * of the data being stored in the cache.\r\n     */\r\n    ttl?: number | null\r\n};\r\n\r\nexport interface KeyValueCache<V = string> {\r\n    get(key: string): Promise<V | undefined>;\r\n    set(key: string, value: V, options?: KeyValueCacheSetOptions): Promise<void>;\r\n    delete(key: string): Promise<boolean | void>;\r\n}\r\n"],"names":["fetch","Response","Request"],"mappings":"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"}